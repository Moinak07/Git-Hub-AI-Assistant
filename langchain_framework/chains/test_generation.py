import json
import re
import os
import sys
from dotenv import load_dotenv
load_dotenv()

util_path = os.getenv("UTIL_PATH")

if util_path:
    sys.path.append(util_path)
else:
    print("Warning: PROJECT_PATH is not set in the .env file.")
from flask import Flask, request, jsonify
import requests
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain_setup import get_llm  # Ensure this is implemented correctly

app = Flask(__name__)

EXPRESS_BACKEND_URL = "http://localhost:3000/api/github/pulls"  # Express API Endpoint

def generate_test_cases(patch_data):
    print("Received Patch Data:", patch_data)

    """Generates test cases from the patch using an LLM."""
    prompt = PromptTemplate.from_template("""
    You are an expert software tester. Given the following **code patch** from a GitHub pull request:

    ```
    {patch_data}
    ```

    - Analyze **only the modified lines of code** in the patch.
    - Generate relevant test cases that **validate the changes**.
    - Ensure coverage of:
        - Functional correctness of modified code.
        - Edge cases and regression tests for affected areas.
        - Styling, UI behavior, or logic changes if applicable.

        "test_name": "Describe what is being tested",
                "unit test code": "Generate the Unit test code to test the change ",
                "expected_output": "Expected behavior after the change"
  
    ```
    """)

    llm = get_llm()
    chain = prompt | llm

    try:
        response = chain.invoke({"patch_data": patch_data})
        response_content = response.content.strip()

        print("\nüîπ Raw LLM Response:\n", response_content)  # Debugging

        # Remove any markdown formatting (```json ... ```)
        response_content = re.sub(r'```(?:json)?\n?(.*?)\n?```', r'\1', response_content, flags=re.DOTALL).strip()

        print("\nüîπ Cleaned LLM Response:\n", response_content)  # Debugging
        return response_content

        # Validate JSON
        # try:
        #     json_response = json.loads(response_content)  # Ensure it's valid JSON
        # except json.JSONDecodeError as e:
        #     print("\n‚ùå Invalid JSON from LLM:", response_content)
        #     return {"response_code": 500, "error": "Invalid JSON generated by LLM", "details": str(e)}

        # return json_response

    except Exception as e:
        print(f"\n‚ùå Error generating test cases: {e}")
        return {"response_code": 500, "error": "Failed to generate test cases", "details": str(e)}

@app.route("/generate-test-cases", methods=["GET"])
def fetch_and_generate_tests():
    """Fetches PR patch data from Express backend and generates test cases using LLM."""
    try:
        # Fetch data from Express backend
        response = requests.get(EXPRESS_BACKEND_URL)

        print("\nüîπ Express Backend Response Status:", response.status_code)  # Debugging
        print("\nüîπ Express Backend Raw Response:\n", response.text)  # Debugging

        if response.status_code != 200:
            return jsonify({"error": "Failed to fetch data from Express backend"}), 500

        # Parse JSON response
        try:
            issue_data = response.json()
        except ValueError:
            return jsonify({"error": "Invalid JSON response from Express backend"}), 500

        # Extract patches from files
        files = issue_data.get("data", {}).get("files", [])  # Access files safely
        patches = [file.get("patch", "") for file in files if "patch" in file]

        # Join all patches into a single string
        patch_data = "\n".join(patches)

        # Generate test cases
        test_cases = generate_test_cases(patch_data)

        return jsonify(test_cases)

    except requests.RequestException as e:
        return jsonify({"error": "Request to Express backend failed", "details": str(e)}), 500

if __name__ == "__main__":
    app.run(debug=True)
